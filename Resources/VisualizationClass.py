from plotly import graph_objs as go
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

from Resources.AcquisitionClass import UserAcquisition

acq_obj = UserAcquisition()


class Visualisations:
    def __init__(self):
        pass

    def plot_stacked_funnel(self, df, steps, col=None, from_date=None, to_date=None, step_interval=pd.to_timedelta('0')):
        """
        Function used for producing a funnel plot
        """

        # create list to append each trace to
        # this will be passed to "go.Figure" at the end
        data = []

        # if col is provided, create a funnel_df for each entry in the "col"
        if col:
            # generate dict of funnel dataframes
            dict_ = acq_obj.group_funnel_dfs(df, steps, col)
            title = 'Funnel plot per {}'.format(col)
        else:
            funnel_df = acq_obj.create_funnel_df(df, steps, from_date=from_date, to_date=to_date,
                                                 step_interval=step_interval)
            dict_ = {'Total': funnel_df}
            title = 'Funnel plot'

        for t in dict_.keys():
            trace = go.Funnel(
                name=t,
                y=dict_[t].step.values,
                x=dict_[t].val.values,
                textinfo="value+percent previous"
            )
            data.append(trace)

        layout = go.Layout(margin={"l": 180, "r": 0, "t": 30, "b": 0, "pad": 0},
                           funnelmode="stack",
                           showlegend=True,
                           hovermode='closest',
                           title='Funnel plot per {}'.format(col),
                           legend=dict(orientation="v",
                                       bgcolor='#E2E2E2',
                                       xanchor='left',
                                       font=dict(
                                           size=12)
                                       )
                           )

        return go.Figure(data, layout)

    def growth(self, df, event, user_category, period='week', month_format='period'):
        """
        Function use to create multi-axes plot and table for all the stats generated by
        "stats.retention.users_per_period"
        """

        # generate user stats per period
        df = acq_obj.users_per_period(df, event, user_category, period, month_format)

        # needed to convert the month period to time_manipulations
        if period == 'month':
            df.index = df.index.to_timestamp().strftime("%Y-%m")

        # new users
        new1 = go.Bar(
            x=df.index,
            y=df['new_users'].values,
            text=df['new_users'].values,
            textposition='auto',
            marker=dict(
                color='rgb(0,0,204)'),
            name='New Users (total)',
            xaxis='x1',
            yaxis='y1'
        )

        # new users for 2nd axis
        new2 = go.Bar(
            x=df.index,
            y=df['new_users'].values,
            text=df['new_users'].values,
            textposition='auto',
            marker=dict(
                color='rgb(0,0,204)'),
            name='New Users (total)',
            xaxis='x1',
            yaxis='y2'
        )

        # organic users
        organic = go.Bar(
            x=df.index,
            y=df['new_organic_users'].values,
            text=df['new_organic_users'].values,
            textposition='auto',
            xaxis='x1',
            yaxis='y1',
            marker=dict(
                color='rgb(58,193,0)'),
            name='New Organic Users'
        )

        # paid users
        non_organic = go.Bar(
            x=df.index,
            y=df['new_non_organic_users'].values,
            text=df['new_non_organic_users'].values,
            textposition='auto',
            xaxis='x1',
            yaxis='y1',
            marker=dict(
                color='rgb(255,0,0)'),
            name='New Non-organic Users'
        )

        # active users
        active = go.Bar(
            x=df.index,
            y=df['active_users'].values,
            text=df['active_users'].values,
            textposition='auto',
            name='Active Users',
            xaxis='x1',
            yaxis='y2',
            marker=dict(
                color='rgb(153,0,76)')
        )

        # returning users
        returning = go.Bar(
            x=df.index,
            y=df['returning_users'].values,
            text=df['returning_users'].values,
            textposition='auto',
            name='Returning Users',
            xaxis='x1',
            yaxis='y2',
            marker=dict(
                color='rgb(255,128,0)')
        )

        # periodic growth
        growth = go.Scatter(
            x=df.index,
            y=df['w/w_growth'].values,
            name='period-on-period Growth',
            xaxis='x1',
            yaxis='y3',
            marker=dict(
                color='rgb(0,153,153)')
        )

        # NR ratio
        NR_ratio = go.Scatter(
            x=df.index,
            y=df['new/return_ratio'].values,
            name='New:Returning Ratio',
            xaxis='x1',
            yaxis='y4',
            marker=dict(
                color='rgb(192,192,192)')
        )

        # axis object
        axis = dict(
            showline=True,
            zeroline=False,
            showgrid=True,
            ticklen=4,
            gridcolor='#ffffff',
            tickfont=dict(size=10),
            linecolor='black',
            linewidth=1
        )

        layout = dict(
            width=950,
            height=800,
            autosize=True,
            barmode='group',
            margin={"l": 100, "r": 0, "t": 10, "b": 0, "pad": 0},
            showlegend=True,
            xaxis1=dict(axis, **dict(domain=[0, 1], anchor='y1', showticklabels=True,
                                     ticktext=df.index,
                                     tickvals=df.index,
                                     tickangle=-45),
                        rangeselector=dict(
                            buttons=list([
                                dict(count=1,
                                     label="1m",
                                     step="month",
                                     stepmode="backward"),
                                dict(count=3,
                                     label="3m",
                                     step="month",
                                     stepmode="backward"),
                                dict(count=6,
                                     label="6m",
                                     step="month",
                                     stepmode="backward"),
                                dict(count=1,
                                     label="1yr",
                                     step="year",
                                     stepmode="backward"),
                                dict(step="all")
                            ])
                        ),
                        rangeslider=dict(
                            visible=False,
                            thickness=0.05
                        ),
                        type="date"),
            yaxis1=dict(axis, **dict(domain=[0, 0.10], anchor='x1', title='New users<br>per category')),
            yaxis2=dict(axis, **dict(domain=[0.12, 0.7], anchor='x1', title='New/Active/<br>Returning')),
            yaxis3=dict(axis, **dict(domain=[0.705, 0.85], anchor='x1', hoverformat='.2f', title='Growth%')),
            yaxis4=dict(axis, **dict(domain=[0.855, 1], anchor='x1', title='NR<br>Ratio')),
            plot_bgcolor='rgba(228, 222, 239, 0.65)',
            hovermode='closest'
        )

        data = [new1, organic, non_organic,
                new2, active, returning,
                growth,
                NR_ratio]

        return dict(data=data, layout=layout)

    def retention_heatmap(self, df, figsize=(12, 6), type='val'):
        """
        Function used to plot retention heatmaps.
        """
        sns.set()

        # used to set the number format (values vs percentages)
        if type == 'val':
            values_fmt = '.0f'
        else:
            values_fmt = '.0%'

        plt.figure(figsize=figsize)
        h = sns.heatmap(df,
                        cmap='Blues',
                        annot=True,
                        yticklabels=list(zip(df.index.get_level_values(0).strftime('%Y-%m-%d').values,
                                         df.index.get_level_values(1))),
                        annot_kws={'fontsize': 14},
                        fmt=values_fmt)
        plt.yticks(rotation=0, fontsize=14)
        plt.xticks(rotation=0, fontsize=14)
        plt.xlabel('\nCohort Period', fontsize=16)
        plt.ylabel('(Cohort, Cohort Size)\n', fontsize=16)
        plt.title('Retention (%)', fontsize=20)

        return h, plt

    def plot_user_flow(self, df, starting_step, n_steps=3, events_per_step=5, title='Sankey Diagram'):
        """
        Function used to generate the sankey plot for user journeys.
        """
        # transform raw events dataframe into  source:target pairs including node ids and count of each combination
        label_list, colors_list, source_target_df = acq_obj.sankey_df(df, starting_step, n_steps, events_per_step)

        # creating the sankey diagram
        data = dict(
            type='sankey',
            node=dict(
                pad=20,
                thickness=20,
                color=colors_list,
                line=dict(
                    color="black",
                    width=0.5
                ),
                label=label_list
            ),
            link=dict(
                source=source_target_df['source_id'].values.tolist(),
                target=source_target_df['target_id'].values.tolist(),
                value=source_target_df['count'].astype(int).values.tolist(),
                hoverlabel=dict(
                    bgcolor='#C2C4C7')
            )
        )

        # set window width
        if n_steps < 5:
            width = None
        else:
            width = n_steps * 250

        layout = dict(
            height=600,
            width=width,
            margin=dict(t=30, l=0, r=0, b=30),
            #         autosize=True,
            title=title,
            font=dict(
                size=10
            )
        )

        fig = dict(data=[data], layout=layout)
        return fig
